#!/home/grimalkin/.arturo/bin/arturo -e
;==========================================
; Advent of Code solution 
;
; @file: tools/<year>_<day>.art (or default)
; @author: Mixomycetes
;==========================================

FilenamewoExtention: first split.by:"." last split.by:"/" env\_ ; eg /mnt/c/Users/Grim/AoC/2023/2023_1.art'
[year,day]: split.by:"_" FilenamewoExtention   ; 2023 1 ;print [day,year]


demoinput: [
"467..114.."
"...*......"
"..35..633."
"......#..."
"617*......"
".....+.58."
"..592....."
"......755."
"...$.*...."
".664.598.."
]
 


; actual inject example here (into inptustr)
;do "../helperfiles/GetAoCData.art"
year: 2023
day: 3
; inputstr: chop read.lines ~"../data/input|year|_|day|.txt"; for B
;inputstr: chop read.lines data

;; toy demo example
inputstr: demoinput


;pattern: {/[^0-9.]/}

;inputstr:  (replace inputstr pattern "_")


print inputstr


 
parsemask: $[inputstr][
    mask: []
    
    loop.with: 'x (inputstr) 'line [
        
        ;print line
        
        loop.with: 'y (split line) 'char [
            
            ;print [x ", "y "," line]
            ;ditgitlistwdot: (split ".0123456789")
            if? (in? char  ".0123456789")  [ ]; ignore
            else [
 
                loop @[(x-1) (x+0) (x+1)] 'xx [
                    loop @[(y-1) (y+0) (y+1)] 'yy [
                    ;print [xx ";" yy]
                    'mask ++ @[@[xx yy]]
                    
                ] ]
                ;print ["added" x","y]
  ]
  
  ]
  ;print unique mask
    ]
    return unique mask
]


 
parsestarmask: $[inputstr][
    mask: []
    
    loop.with: 'x (inputstr) 'line [
        
        ;print line
 
        loop.with: 'y (split line) 'char [
            
            ;print [x ", "y "," line]
            ;ditgitlistwdot: (split ".0123456789")
            if? (in? char ".0123456789")  [ ]; ignore
            else [
                if (in? char (split "*"))  [ 
                loop @[(x-1) (x+0) (x+1)] 'xx [
                    loop @[(y-1) (y+0) (y+1)] 'yy [
                    ;print [xx ";" yy]
                    'mask ++ @[@[xx yy]]
                    ]; ignore
                    
                ] ]
                ;print ["added" x","y]
  ]
  
  ]
  ;print unique mask
    ]

occurences: tally mask 
starmask: []
loop keys occurences 'pair [
    print [pair occurences\[pair]]
    if equal? occurences\[pair] 2 =>  'starmask ++ pair
]
    return starmask
]



;print mask
    ;print dictlist
solveA: $[mask inputstr][
    currnr: []
    valids: []
    isvalid: 0
    print ["before loop"]            
    ;print mask
    
    x: neg 1
    y: neg 1
    loop inputstr 'line [
        inc 'x
        
        'isvalid: 0
        'y: neg 1
        



        loop split line 'char [
            inc 'y
            ;print ["(" x ", " y "): "char ]
            ; print char
            ;a: new x
            ;b: new y    
            ;print(~"x,y |a| |b|")
            ;if (equal? x 139) [print line 
                        ;print ["x" x "y" y]    
                        ;pause 200
                        ;print char
             ;           ]
             
             ;digitlist: (split "0123456789")
             
             if? (in? char @(split "0123456789"))  [
                ;print [ "char is digit: " char]
                'currnr ++ char
                ;print ["digit added: " line]
                ;print [ "eval " @[x y] ]

               if (in? @[x y] mask) [
                                    'isvalid: 1 
                                    ;print ["valid "]; currnr]
                                        ]
                   ]
              else [ ; char is no number => store number.
                    ;print [ "char NOT digit: " char]
                    if? (not? zero? isvalid)  [
                        if ((size currnr)>0) [
                        ;print  [ currnr " written " ]
                        nextnr: to :integer (join currnr)
                        'valids ++ nextnr
                        ;print ["added " nextnr]
                        ]
                        ;print valids
                        'isvalid: 0
                        'currnr: [  ]
                        ;print "reset"
                 ]
                if (not? in? char @(split "0123456789")) [
                                'isvalid: 0
                                'currnr: [  ]
                                 ;print ["removed isvalid" char]
                                 ]
                 ;print isvalid
                 ] 
        ]
        ;; end of line edge-case
                     if (not? zero? isvalid)  [
                         ;print  @[ currnr " written " ]
                         if ((size currnr)>0) [
                         nextnr: to :integer (join currnr)
                        ;print ["added " nextnr]
                        'valids ++ nextnr
                        
                        ]
                        ;print valids
                        'isvalid: 0
                        'currnr: [ ]
                        ;print "reset"
                    ]
    ] 
    
print valids

;print [" size valids: " size valids]

return sum valids ; 4298,3631 too high.
]


solveB: $[starmask inputstr][
    
    return (0 ) ; 4298,3631 too high.
]



;dictlist: parse mask
;print(dictlist)


t0: benchmark.get [
    
mask: parsemask inputstr ;inputstr
starmask: parsestarmask  inputstr
print starmask
print ["mask built"]
]
t1: benchmark.get [

 print [~"|year| |day| a: " solveA mask inputstr] ; 474678, 505766 too low   X  88390 505766  552395 507255  x -> too low? 474678 505766   => way too low . 153721 516573 x  156050 514347
 ; untested 156050    530105  ; 521524    ; 532331
 ; 521524 x  532331
 ] 
t2: benchmark.get  [
 print [~"|year| |day| b: " (solveB mask )] ; 2 less bc of white line in end
]

print(~"Time to parse:  \n |year|\\|day|parse) |t0| \n Time to solve: \n |year|\\|day|a) |t2| \n |year|\\|day|b) |t1|")
