#!/bin/arturo -u
;:==========================================
;; Advent of Code solution 
;;
;: @file: 2025/<year>_<day>.art (or default)
;: @input: inputs/<year>_<day>.art (or default)
;: @author: Mixo
;
; global setup:
import "helperfiles/GetAoCData.art"  ; loads helperfunctions, a.o fetching datafile 
FilenamewoExtention: first split.by:"." last split.by:"/" env\_ 
[year,day]: split.by:"_" FilenamewoExtention   ; extract year and day from filename.
day: to :string to :integer day ; stripping leading zeros, if present.
;
;;==========================================



; ------ Input & parsing -----------------------------------------
getinput: $[][

    print ["Day year " day year ]

    ; personal data
    P: do [FetchInput year day]
    
    ; demodata
        D: {L68
            L30
            R48
            L5
            R60
            L55
            L1
            L99
            R14
            L82
            }

    inputstr: split.lines P; D ; Pinput; Dinput 
    return inputstr
]


; ------Helperfunctions  -----------------------------------------

parsethis: $[theinput] [
    alist:[] ; start  
        alist:  chop  map theinput 'v  [replace v ["R" "L" ] ["" "-"]]
        alist: map alist 'w [to :integer w ]
    return alist
    ]

strictmod100: $ [v][((v % 100) +100)%100] ; clams between 0 and 99

; ------Solution A -----------------------------------------


solve_A:$[alist]
 [
    
    pos: [50]
    loop alist 'delta [
        'pos ++ strictmod100 delta + last pos
        ]    
    return get (tally pos) "0"
 ]


; ----- Solution B------------------------------------------
solve_B:$[alist]
 [
        ; startpos at 0, and trigger at 50?
        pos: [50]
        loop alist 'delta [
            'pos ++ mod (delta + last pos) 100
        ]    

        strictpos: [50]
        loop alist 'delta [
            'strictpos ++ strictmod100 ((last strictpos) + delta)
        ]    

        abspos: [100050]
        loop alist 'delta [
            'abspos ++ ((last abspos) + delta)
        ]    
        
        ;print ["pos" pos]
        ;print ["abspos" abspos]
        ;print ["strictpos" strictpos]
        
        ; bruteforce my way, inspired by Krenium:
        crossings: [0]
        extracrossings: 0

        ;endedonclick: 0
        ;startedonclick: 0
        ;zerocrossings: 0
        loop 0..(dec dec size abspos) 'anindex [
                                        ;print ["index " anindex extracrossings abspos\[(anindex)] abspos\[(anindex+1)]] 

                                        ;minval: (min @[(abspos\[anindex]), (abspos\[anindex+1])])
                                        ;maxval: (max @[(abspos\[anindex]), (abspos\[anindex+1])])
                                        ; crossings bc of multiples of 100's
                                        ;print [@[minval maxval]]
                                        
                                        zerocrossings: abs ((abspos\[anindex])-(abspos\[anindex+1]))/100
                                        ;print zerocrossings
                                        delta: alist\[anindex]
                                        startpos: strictpos\[anindex]
                                        rel_endpos: (startpos+ delta ) 
                                        additionalcrossing: 1

                                        ;; missing one crossings if strictpos + mod_value if > 100 or < 0.
                                        if all? @[(between? (strictpos\[anindex]+ mod delta 100) 1 99)  ] [additionalcrossing: 0]
                                        ;if all? @[(startpos =< 50)   (between? (pos\[anindex]+delta) 50 150 )      ] [additionalcrossing: 1]
                                        ;if all? @[(startpos >= 50)   (between? (pos\[anindex]+delta) (neg 50) 50)  ] [additionalcrossing: 1]


                                        ;  get rid of count if it ends on click, counted later w method A)
                                        endedonclick:   0
                                        startedonclick: 0
                                        if (0 = strictmod100 abspos\[anindex]  )  [startedonclick: 1]
                                        if (0 = strictmod100 abspos\[anindex+1])  [endedonclick: 1]

                                        ;print (zerocrossings-startedonclick + endedonclick)
                                        'extracrossings: max @[0 (zerocrossings+ max @[0 additionalcrossing - (startedonclick + endedonclick)])]
                                        ;print ["zerocrossings" zerocrossings "extracrossings" extracrossings] 
                                        'crossings ++ extracrossings
                                        
                                        
                                        ]
        
        ;print delta_steps
        ;print ["crossings" crossings]
        method_A_answer: get (tally pos) "0"
        print ["method_A_answer" method_A_answer]
    return (sum crossings) + method_A_answer ; ((sum delta_steps)-removetozero)  ; - 2*get (tally pos) 0
 ]


; -----Main loop ------------------------------------------
main: $[][
    inputstr: getinput

    alist: parsethis inputstr
    ;print alist
    t1: benchmark.get [
    print [~"|year| |day| a: " (solve_A alist) " should equal 1165"] ; 
    ]
        
    t2: benchmark.get  [
    print [~"|year| |day| b: " (solve_B alist) " should equal  P2:6568 x => 6496"] ;
    ]

    print(~"Time to solve: \n |year|\\|day|a) |t1| \n |year|\\|day|b) |t2|")

]

main ; exectute main.
; -----The End  ------------------------------------------
