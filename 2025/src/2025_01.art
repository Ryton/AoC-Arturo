#!/bin/arturo -u
;:==========================================
;; Advent of Code solution 
;;
;: @file: 2025/<year>_<day>.art (or default)
;: @input: inputs/<year>_<day>.art (or default)
;: @author: Mixo
;
; global setup:
import "helperfiles/GetAoCData.art"  ; loads helperfunctions, a.o fetching datafile 
FilenamewoExtention: first split.by:"." last split.by:"/" env\_ 
[year,day]: split.by:"_" FilenamewoExtention   ; extract year and day from filename.
day: to :string to :integer day ; stripping leading zeros, if present.
;
;;==========================================



; ------ Input & parsing -----------------------------------------
getinput: $[][

    print ["Day year " day year ]

    ; personal data
    P: do [FetchInput year day]
    
    ; demodata
        D: {L68
            L30
            R48
            L5
            R60
            L55
            L1
            L99
            R14
            L82
            }

    inputstr: split.lines P; D ; Pinput; Dinput 
    return inputstr
]


; ------Helperfunctions  -----------------------------------------

parsethis: $[theinput] [
    alist:[] ; start  
        alist:  chop  map theinput 'v  [replace v ["R" "L" ] ["" "-"]]
        alist: map alist 'w [to :integer w ]
    return alist
    ]

strictmod100: $ [v][((v % 100) +100)%100] ; clams between 0 and 99

; ------Solution A -----------------------------------------
solve_A:$[alist]
 [
    pos: [50]
    loop alist 'delta [
        'pos ++ strictmod100 delta + last pos
        ]    
    return get (tally pos) "0"
 ]

; ----- Solution B------------------------------------------
solve_B:$[alist]
 [
        ; startpos at 0, and trigger at 50?
        pos: [50]
        loop alist 'delta [
            'pos ++ mod (delta + last pos) 100
        ]    

        strictpos: [50]
        loop alist 'delta [
            'strictpos ++ strictmod100 ((last strictpos) + delta)
        ]    

        abspos: [100050]
        loop alist 'delta [
            'abspos ++ ((last abspos) + delta)
        ]    
        crossings: [0]
        extracrossings: 0
        loop 0..(dec dec size abspos) 'anindex [
                                        zerocrossings: abs ((abspos\[anindex])-(abspos\[anindex+1]))/100
                                        delta: alist\[anindex]
                                        startpos: strictpos\[anindex]
                                        rel_endpos: (startpos+ delta ) 
                                        additionalcrossing: 1
                                        ;; missing one crossings if strictpos + mod_value if > 100 or < 0.
                                        if all? @[(between? (strictpos\[anindex]+ mod delta 100) 1 99)  ] [additionalcrossing: 0]

                                        ;  get rid of count if it ends on click, counted later w method A)
                                        endedonclick:   0
                                        startedonclick: 0
                                        if (0 = strictmod100 abspos\[anindex]  )  [startedonclick: 1]
                                        if (0 = strictmod100 abspos\[anindex+1])  [endedonclick: 1]
                                        'extracrossings: max @[0 (zerocrossings+ max @[0 additionalcrossing - (startedonclick + endedonclick)])]
                                        'crossings ++ extracrossings
                                        ]        
        method_A_answer: get (tally pos) "0"
    return (sum crossings) + method_A_answer 
 ]


; -----Main loop ------------------------------------------
main: $[][
    inputstr: getinput

    alist: parsethis inputstr
    ;print alist
    t1: benchmark.get [
    print [~"|year| |day| a: " (solve_A alist) " "] ; 
    ]
        
    t2: benchmark.get  [
    print [~"|year| |day| b: " (solve_B alist) " "] ;
    ]

    print(~"Time to solve: \n |year|\\|day|a) |t1| \n |year|\\|day|b) |t2|")

]

main ; exectute main.
; -----The End  ------------------------------------------
