#!/bin/arturo -u
;:==========================================
;; Advent of Code solution 
;;
;: @file: 2025/<year>_<day>.art (or default)
;: @input: inputs/<year>_<day>.art (or default)
;: @author: Mixo
;
; global setup:
import "helperfiles/GetAoCData.art"  ; loads helperfunctions, a.o fetching datafile 
FilenamewoExtention: first split.by:"." last split.by:"/" env\_ 
[year,day]: split.by:"_" FilenamewoExtention   ; extract year and day from filename.
day: to :string to :integer day ; stripping leading zeros, if present.
;
;;==========================================

import "tabular"!
; ------ Input & parsing -----------------------------------------
getinput: $[][

    ; demodata
    D: {..@@.@@@@.
        @@@.@.@.@@
        @@@@@.@.@@
        @.@@@@..@.
        @@.@@@@.@@
        .@@@@@@@.@
        .@.@.@.@@@
        @.@@@.@@@@
        .@@@@@@@@.
        @.@.@@@.@.
        }

    print ["Day year " day year ]

    ; personal data
    P:  FetchInput year day

 
    return P
]

parsethis: $[i] [
    output: i   | replace "@" "x"
                | split.by: "\n"
                | chop  ;; thiis should be removed for demo data! 
                | map =>  strip
                | map =>  split
    ;print ["input" i]
    return  output
    ]

extend: $[parsed] [
    H: (size parsed)
    W: (size parsed\[0])
    value: 0

    Grid: array.of: @[(W+2), (H+2)]  "."
    
        loop (1..H) 'y [
            loop (1..W) 'x [            
                Grid\[x]\[y]: (parsed\[y-1]\[x-1])
                            ]
            ]
    ;print "Grid"

    return Grid
    
    ]


xypairs: flatten.once map @[(neg 1) 0 1] 'x [ map @[(neg 1) 0 1] 'y [@[(x),(y)]]]


boxCount?:  $[pos Grid][
        boxsymbol:"x"
        symbol:"D"
        aline: ""
        return size select xypairs 'xyp [
            x: ((first pos) + first xyp )
            y: ((last pos) + last xyp)            
            symbol: (Grid\[(x)]\[(y)])
            ;inspect symbol
             (equal? symbol boxsymbol)
            ]
        

]
    
; ------Solution A -----------------------------------------

solve_A:$[parsed]
 [
    H: (size parsed)
    W: (size parsed\[0])
    Grid: (extend parsed)
    boxsymbol:"x"
    aline: ""
    symbolHere:[]
    boxpositions: []
    loop 1..W 'x[
        loop 1..H 'y [
            'aline: (Grid\[(x)])
            ;print (aline)
            'symbolHere: get aline (y)
            if ((symbolHere)=(boxsymbol)) ['boxpositions ++ @[@[(x) (y)]]]

        ]
    ]
    boxesremoved: 0
    changed: 0
        loop boxpositions 'pos [
            if (5 > boxCount? pos Grid) [inc 'boxesremoved ]
            ]
            
    return boxesremoved
 ]


; ----- Solution B------------------------------------------
solve_B:$[parsed]
 [
    H: (size parsed)
    W: (size parsed\[0])
    Grid: (extend parsed)
    startamount: get (tally flatten Grid ) "x"
    endamount: (new startamount) - 1
    currentamount: 0
    boxsymbol:"x"
    boxesremoved: 0
    prevQTTbox: neg 1
    aline: ""
    changed: 1
    symbolHere:[]
    boxpositions: []
    nextboxpositions: []
    boxPOSremoved: []
    
    loop 1..H 'x[
        loop 1..W 'y [
            'aline: (Grid\[(x)])
            ;print (aline)
            'symbolHere: aline\[(y)]
            if ((symbolHere)=(boxsymbol)) ['boxpositions ++ @[@[(x) (y)]]]

        ]
    ]
    
    while [not? equal? currentamount endamount] [ ; could do while too.

        currentamount: new endamount
        ; check new state
        loop boxpositions 'pos [                
                if (5 > boxCount? pos Grid) [
                    [x,y] : pos 
                        inc 'boxesremoved 
                        'changed: 1 
                        'aline: (Grid\[(x)])
                        aline\[(y)]:"u"
                        Grid\[(x)]: aline
                ]
            ]

        endamount: get (tally flatten Grid ) "x"
        ]
    return startamount-endamount
 ]


; -----Main loop ------------------------------------------
main: $[][
    inputstr: getinput
    
    parsed: parsethis inputstr

    t1: benchmark.get [
    print [~"|year| |day| a: " (solve_A parsed)] ; 2 less bc of white line in end
    ]
    t2: benchmark.get  [
    print [~"|year| |day| b: " (solve_B parsed )] ; 2 less bc of white line in end
    ]

    print(~"Time to solve: \n |year|\\|day|a) |t1| \n |year|\\|day|b) |t2|")

]


main ; exectute main.
; -----The End  ------------------------------------------
